  <html>
<head>
<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0" charset="UTF-8"/>
<link rel="manifest" href="controller/manifest.json">
<link rel="stylesheet" href="controller/button/button.css">
<link rel="stylesheet" href="controller/dpad/dpad.css">
<link rel="stylesheet" href="css/controller.css">
</head>
<body onload='init()'>
  
  <div id="welcome">
    <span style="color:white, font-size:200%">Welcome!</span>
  </div>
  
  <div id="name-and-color">
    <form>
      <div class="name-container">
        Player name: <input type="text" name="player_name" id="player_name">
      </div>
      <div class="color-container">
       <img class="player-color" src="resource/icon_black.png">
       <img class="player-color" src="resource/icon_white.png">
       <img class="player-color" src="resource/icon_blue.png">
       <img class="player-color" src="resource/icon_green.png">
       <img class="player-color" src="resource/icon_red.png">
       <img class="player-color" src="resource/icon_lightblue.png">
       <img class="player-color" src="resource/icon_yellow.png">
       <img class="player-color" src="resource/icon_purple.png">
      </div>
      <div class="play-button">
        <input type="button" value="Play" onClick="getPlayerInfo()">
      </div>
    </form>
  </div>

  <div id="gamepad-container">
    <div id="left" class="left">
      <div id="my-DPad">
        <div>
          <div class="dpad-arrow dpad-arrow-up"></div>
          <div class="dpad-arrow dpad-arrow-down"></div>
          <div class="dpad-arrow dpad-arrow-left"></div>
          <div class="dpad-arrow dpad-arrow-right"></div>
        </div>
      </div>
    </div>
    <div id="middle" class="middle"></div>
    <div id="right" class="right">
      <div id="button-bomb" class="button-300-300"><div class="button-text">BOMB</div></div>
    </div>
  </div>

  <div id="gyro-pad">
    GYROPAD
    <div id="button-bomb-gyro" class="button-300-300"><div class="button-text">BOMB</div></div>
  </div>

  <div id="gyro-calibration">
    <form>
      <div class="calibre-button">
        <div id="debugMessage"></div>
        <div id="calibrateMessage">Tap "Begin" button to start calibration!</div>
        <button id="calibrateBtn" type="button" onClick="gyro.calibrate()">Begin</button>
        <button id="calStartOverBtn" type="button" onClick="gyro.startOver()">Start over!</button>
      </div>
    </form>
  </div>
  
<script type="text/javascript" src="https://www.airconsole.com/api/airconsole-1.3.0.js"></script>
<script type="text/javascript" src="controller/rate-limiter/rate-limiter.js"></script>
<script type="text/javascript" src="controller/dpad/dpad.js"></script>
<script type="text/javascript" src="controller/button/button.js"></script>
<script type="text/javascript" src="controller/rate-limiter/rate-limiter.js"></script>
<script type="text/javascript">
  /* global AirConsole, DPad, Button, GyroNorm, RateLimiter */
  
    navigator.vibrate = (navigator.vibrate ||
                         navigator.webkitVibrate ||
                         navigator.mozVibrate ||
                         navigator.msVibrate);
    
    var nickname;
    var color;
    var gameState;
    var orientationDefault;
    var orientationOpposite = {
      "-90": 90,
      "90": -90,
      "landscape-secondary": 'landscape-primary',
      "landscape-primary": 'landscape-secondary'
    };
    var acTools = {};
    var acInterval;
    var controller = 'DPad'; // DPad, Gyro
    var transitFrom = 'welcome';
    var dpad = {};
    var STILL_SNAP = 10; // [%] of movement to be considered as still player
    var TILT_LIMITER_RATE = 200; // [ms] of minimal time between tilt function executions
    var gyroActual;
    var gyro = {
      init: function(){
        this.startOverBtn.style.display = "none";
      },
      calibrated: false,
      step: 0,
      count: 0,
      message: document.getElementById('calibrateMessage'),
      button: document.getElementById('calibrateBtn'),
      startOverBtn: document.getElementById('calStartOverBtn'),
      debugMessage: document.getElementById('debugMessage'),
      flipCor: 1,
      MAX_BETA: -1000,
      MIN_BETA: 1000,
      MAX_GAMMA: -1000,
      MIN_GAMMA: 1000,
      dirToAxis: {
        LEFT: "x",
        RIGHT: "x",
        UP: "y",
        DOWN: "y"
      },
      dirToSign: {
        LEFT: -1,
        RIGHT: +1,
        UP: -1,
        DOWN: +1
      },
      calibrate: function(){
        if(!orientationDefault){
          orientationDefault = getOrientation();
        }
        
        var self = this;
        var steps = ['BEGIN', 'LEFT', 'RIGHT', 'UP', 'DOWN'];
        
        if(this.step === 0){
          setMessages(steps[++this.step]);
        }else if(this.step === 4){
          this[steps[this.step]] = {beta: gyroActual.beta, gamma: gyroActual.gamma};
          this.step = 1;
          setMessages(steps[++this.step]);
          this.calculateLimits();
          this.calibrated = true;
          transitView("name-and-color");
        }else{
          this[steps[this.step]] = {beta: gyroActual.beta, gamma: gyroActual.gamma};
          setMessages(steps[++this.step]);
        }
        
        function setMessages(direction){
            self.message.innerHTML = 'Now tilt your controller to desired maximum <b>' + direction + '</b> and then tap the button.';
            self.button.innerHTML = 'MAX ' + direction;
        }
      },
      calculateLimits: function(){
        var sides = ['LEFT', 'RIGHT', 'UP', 'DOWN'];
            
        for (var i = 0; i < sides.length; i++) {
          var side = sides[i],
            beta = this[side].beta,
            gamma = this[side].gamma;
          if(beta < this.MIN_BETA){
            this.MIN_BETA = beta;
            this.MIN_BETA_SIDE = side;
          }
          if(beta > this.MAX_BETA){
            this.MAX_BETA = beta;
            this.MAX_BETA_SIDE = side;
          }
          if(gamma < this.MIN_GAMMA){
            this.MIN_GAMMA = gamma;
            this.MIN_GAMMA_SIDE = side;
          }
          if(gamma > this.MAX_GAMMA){
            this.MAX_GAMMA = gamma;
            this.MAX_GAMMA_SIDE = side;
          }
        }
        gyro.debugMessage.innerHTML = '2calculateLimits';
        
        // GET CENTER
        this.CENTER = {
          beta: (this.MIN_BETA + this.MAX_BETA)/2,
          gamma: (this.MIN_GAMMA + this.MAX_GAMMA)/2
        };
        gyro.debugMessage.innerHTML = '3calculateLimits';
        
        // NORMALISE
        this.MIN_BETA -= this.CENTER.beta;
        this.MAX_BETA -= this.CENTER.beta;
        this.MIN_GAMMA -= this.CENTER.gamma;
        this.MAX_GAMMA -= this.CENTER.gamma;
      },
      repeatMessage: function(dir){
        this.message.innerHTML = 'This side was already used for ' + dir + '! Please try again, or tap to "Start over" button, for restarting calibration.';
        this.startOverBtn.style.display = "block";
      },
      startOver: function(){
        this.message.innerHTML = 'Tap "Begin" button to start calibration!';
        this.button.innerHTML = 'Begin';
        this.step = 1;
        this.startOverBtn.style.display = "none";
      }
    };

    acTools.listeners = {};
    acTools.uniListeners = [];
    acTools.addListener = function(name, fn){
    	if(!fn){
    		return;
    	}else if(typeof name !== 'string'){
    		if(typeof name === 'undefined'){
    			acTools.uniListeners.push(fn);
    		}
    		return;
    	}
    	acTools.listeners[name] = fn;	
    };
    acTools.rmListener = function(name, fn){
    	if(fn && typeof name === 'undefined'){
    		var index = acTools.uniListeners.indexOf(fn);
    		acTools.uniListeners.splice(index, 1);
    	}else{
    		delete acTools.listeners[name];
    	}
    };
    acTools.onMessage = function(device_id, data) {
    	if(data.listener && acTools.listeners[data.listener]){
    		acTools.listeners[data.listener](device_id, data);
    	}
    	for (var i = 0; i < acTools.uniListeners.length; i++) {
    		acTools.uniListeners[i](device_id, data);
    	}
    };
    
    var airconsole = new AirConsole({
                            orientation: AirConsole.ORIENTATION_LANDSCAPE,
                            device_motion: 100
                          });
    // rateLimiter -> https://github.com/AirConsole/airconsole-controls/tree/master/rate-limiter                      
    var rateLimiter = new RateLimiter(airconsole);
      
    new DPad("my-DPad", {
      // Set to true if you want to have a relative swipe dpad
      "relative": false,
      // Gets called when the dpad direction changes.
      // Key is one of: DPad.UP, DPad.DOWN, DPad.LEFT, DPad.RIGHT.
      // Pressed is a boolean, true if the direction is active.
      "directionchange": function(key, pressed) {
        if(controller === 'DPad'){
          switch(key) {
            case 'right':
                dpad.x = pressed ? 1 : 0;
                break;
            case 'left':
                dpad.x = pressed ? -1 : 0;
                break;
            case 'up':
                dpad.y = pressed ? -1 : 0;
                break;
            case 'down':
                dpad.y = pressed ? 1 : 0;
                break;
          }
        }
        moveDPad();
      },

      // // Gets called when the DPad is touched.
      // "touchstart": function() {
      //   console.log('touch start');
      // },

      // // Gets called when the DPad is released.
      // // had_direction is a boolean that tells you if at lease one direction was active.
      // //               can be used to determine if it was just a "tap" on the DPad.
      // "touchend": function(had_direction) {
      //   console.log('touch end', had_direction);
      // },

      // (Optional) distance which the user needs to move before triggering a direction.
      "distance": {x: 10, y:10},

      // (Optional) diagonal: If true, diagonal movement are possible and it becomes a 8-way DPad:
      //                      For exmaple UP and RIGHT at the same time.
      "diagonal": true
    });
    
    new Button("button-bomb", {
        "down": function() {
          bomb('setting');
        },
        "up": function() {
          bomb(!'setting');
        }
      });
    
    new Button("button-bomb-gyro", {
        "down": function() {
          bomb('setting');
        },
        "up": function() {
          bomb(!'setting');
        }
      });
      
      
    
// FUNCTION DEFINITIONS: ***********************************************************************************************************************************************************************************
    
    function init() {
      // standard listeners for some devices (e.g. Samsung Galaxy S4 mini)
      if (window.DeviceOrientationEvent) {
        window.addEventListener("deviceorientation", getDoListener('deviceorientation'), true);
      } else if (window.DeviceMotionEvent) {
        window.addEventListener('devicemotion', function (event) {
            tilt({source: 'devicemotion', beta: event.acceleration.x * 2, gamma: event.acceleration.y * 2});
        }, true);
      } else {
        window.addEventListener("MozOrientation", function (event) {
            event.gamma = -(event.x * (180 / Math.PI));
            event.beta = -(event.y * (180 / Math.PI));
            tilt({source: 'MozOrientation', beta: event.beta, gamma: event.gamma});
        }, true);
      }
      
      // secondary listeners for some devices (e.g. Iphone)
      airconsole.onDeviceMotion =  getDoListener('onDeviceMotion');
      
      window.addEventListener("orientationchange", function() {
        if(!orientationDefault){
          return;
        }
        
        var currentOrientation = getOrientation();
        if(currentOrientation === orientationOpposite[orientationDefault]){
          document.body.classList.add('upside-down');
          gyro.flipCor = -1;
          
        }else{
          document.body.classList.remove('upside-down');
          gyro.flipCor = 1;
        }
      });
      
      airconsole.onMessage = acTools.onMessage;
      
      acInterval = setInterval(function(){
        airconsole.message(AirConsole.SCREEN, {listener: 'ready'});
      }, 3000);

      // debug info
      acTools.addListener(undefined, function(from, data){
	      console.log('on ctrl: ', from, data);
      });

      /*
       * Checks if this device is part of the active game.
       */
      airconsole.onActivePlayersChange = function(player) {
        // var div = document.getElementById("player_id");
        // if (player !== undefined) {
        //   div.innerHTML =  (["Left Player", "Right Player"][player]);
        // } else {
        //   div.innerHTML = "It's a 2 player game!";
        // }
      };
      

      /*
       * Makes the device vibrate if the screen says so.
       */
      acTools.addListener('vibrator', function(from, data) {
        if (from == AirConsole.SCREEN && data.vibrate) {
          navigator.vibrate(data.vibrate);
        }
      });
      
      document.addEventListener('click',function(e){
  	  	var clickedElement = e.target;
  	  	if (clickedElement.nodeName == 'IMG'){
  	  	  unselectAll(clickedElement);
  	  	  clickedElement.className += ' selected';
  	  	}
	    });
	    
	    // timeout to get chance gyro/accelerators to fire tilt() function and so tell controller to use gyro functiuonality
      setTimeout(afterInit, 500);
    }
    
    function getOrientation(){
      return screen.orientation || screen.mozOrientation || screen.msOrientation || window.orientation;
    }
    
    function getDoListener(source){
      return function doListener(data) {
        if(data.beta || data.beta === 0){
          tilt({source: source, beta: data.beta, gamma: data.gamma});
        }
      };
    }
      
    function tilt(data){
      if(tiltLimiter()){
        return;
      }
      controller = 'Gyro';
     if(gyro.calibrated){
        // if(gameState === 'level'){
        var mov = process('beta', {x: 0, y:0});
        mov = process('gamma', mov);
        // console.log(mov.x + " - " + mov.y, mov);
        moveGyro(mov);
      // }
    }else{
      gyroActual = data;
    }
    
    function process(name, mov){
      var value = data[name],
        axis, dir;
      
      if(value > gyro.CENTER[name]){
        dir = gyro['MAX_' + name.toUpperCase() + '_SIDE'];
        axis = gyro.dirToAxis[dir];
        mov[axis] = Math.abs(value - gyro.CENTER[name]) / Math.abs(gyro['MAX_' + name.toUpperCase()]);
      }else{
        dir = gyro['MIN_' + name.toUpperCase() + '_SIDE'];
        axis = gyro.dirToAxis[dir];
        mov[axis] = Math.abs(value - gyro.CENTER[name]) / Math.abs(gyro['MIN_' + name.toUpperCase()]);
      }
      
      mov[axis] *= gyro.dirToSign[dir];
      mov[axis] *= gyro.flipCor;
      return mov;
    }
  }
    
  function tiltLimiter(){
    if(this.tiltLimit){
      return true;
    }else{
      this.tiltLimit = true;
      setTimeout(function(){
        this.tiltLimit = false;
      }, TILT_LIMITER_RATE);
      return false;
    }
  }
  
  function afterInit(){
     if(controller === 'DPad'){
        transitView("name-and-color");
      }else{
        gyro.init();
        transitView("gyro-calibration");
      }
  }
    
  function transitView(to){
      document.getElementById(transitFrom).style.display = "none";
      document.getElementById(to).style.display = "block";
      transitFrom = to;
  }

  function getPlayerInfo(){
    
    color = getColor();
    nickname = getName();
    
    if(color && nickname){
      
      if(controller === 'Gyro'){
        transitView("gyro-pad");
      }else{
        transitView("gamepad-container");
      }
      addPlayer(nickname, color);
      
    }
  }
  
  function addPlayer(nickname, color){
    acTools.addListener('ready', function(from, data){
      if(from == AirConsole.SCREEN && !gameState){
        clearInterval(acInterval);
        airconsole.message(AirConsole.SCREEN, {
          listener: 'newPlayer',
          nick: nickname,
          color:color,
          controller: controller
        });
          
        if(data.gameState){
          gameState = data.gameState;
        }
        
        acTools.addListener('gameState', function(from, data){
          if(from == AirConsole.SCREEN && data.gameState){
            gameState = data.gameState;
          }
        });
      }
    });
    airconsole.message(AirConsole.SCREEN, {listener: 'ready'});
  }
  
  function getColor(){
   var el = document.getElementsByClassName('selected');
   if (el[0]){
     var reg = /[a-z]+(?=.png)(?!_)/;
     if(el[0].currentSrc)
       var color = reg.exec(el[0].currentSrc);
     else if (el[0].src)
       var color = reg.exec(el[0].src);
  }
  	
    return color[0];
  }
  
  function getName(){
    return document.getElementById('player_name').value;
  }
      
  function unselectAll(clickedElement){
    var allCharacters = document.getElementsByClassName(clickedElement.className);
    for(var i = 0; i < allCharacters.length; i++)
      allCharacters[i].classList.remove('selected');
  }

    /**
     * Tells the screen to move the paddle of this player.
     * @param amount
     */
    function moveDPad() {
      rateLimiter.message(AirConsole.SCREEN, {
        type: 'DPad',
        listener: 'movePlayer',
        nick: nickname,
        x: dpad.x,
        y: dpad.y
      });
    }
    function moveGyro(data) {
      data.nick = nickname;
      data.type = 'Gyro';
      data.listener = 'movePlayer';
      rateLimiter.message(AirConsole.SCREEN, data);
    }
    function bomb(setting) {
      airconsole.message(AirConsole.SCREEN, {
        listener: 'setBomb',
        nick: nickname,
        setting: setting
      });
    }
    
</script></body></html>