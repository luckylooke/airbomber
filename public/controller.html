  <html>
<head>
<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
<link rel="stylesheet" href="controller/button/button.css">
<link rel="stylesheet" href="controller/dpad/dpad.css">
<link rel="stylesheet" href="css/controller.css">
</head>
<body onload='init()'>
  
  <div id="name-and-color-container">
    <form>
      <div class="name-container">
        Player name: <input type="text" name="player_name" id="player_name">
      </div>
      <div class="color-container">
       <img class="player-color" src="resource/icon_black.png">
       <img class="player-color" src="resource/icon_white.png">
       <img class="player-color" src="resource/icon_blue.png">
       <img class="player-color" src="resource/icon_green.png">
       <img class="player-color" src="resource/icon_black.png">
       <img class="player-color" src="resource/icon_white.png">
       <img class="player-color" src="resource/icon_blue.png">
       <img class="player-color" src="resource/icon_green.png">
      </div>
      <div class="play-button">
        <input type="button" value="Play" onClick="getPlayerInfo()">
      </div>
    </form>
  </div>

  <div id="gamepad-container">
    <div id="left" class="left">
      <div id="my-DPad">
        <div>
          <div class="dpad-arrow dpad-arrow-up"></div>
          <div class="dpad-arrow dpad-arrow-down"></div>
          <div class="dpad-arrow dpad-arrow-left"></div>
          <div class="dpad-arrow dpad-arrow-right"></div>
        </div>
      </div>
    </div>
    <div id="middle" class="middle"></div>
    <div id="right" class="right">
      <div id="button-bomb" class="button-300-300"><div class="button-text">BOMB</div></div>
    </div>
  </div>
  
<script type="text/javascript" src="https://www.airconsole.com/api/airconsole-1.3.0.js"></script>
<script type="text/javascript" src="controller/rate-limiter/rate-limiter.js"></script>
<script type="text/javascript" src="controller/dpad/dpad.js"></script>
<script type="text/javascript" src="controller/button/button.js"></script>
<script type="text/javascript">
  /* global AirConsole, DPad, Button */
    navigator.vibrate = (navigator.vibrate ||
                         navigator.webkitVibrate ||
                         navigator.mozVibrate ||
                         navigator.msVibrate);
    
    var nickname;
    var acTools = {};

    acTools.listeners = {};
    acTools.uniListeners = [];
    acTools.addListener = function(name, fn){
    	if(!fn){
    		return;
    	}else if(typeof name !== 'string'){
    		if(typeof name === 'undefined'){
    			acTools.uniListeners.push(fn);
    		}
    		return;
    	}
    	acTools.listeners[name] = fn;	
    };
    acTools.rmListener = function(name, fn){
    	if(fn && typeof name === 'undefined'){
    		var index = acTools.uniListeners.indexOf(fn);
    		acTools.uniListeners.splice(index, 1);
    	}else{
    		delete acTools.listeners[name];
    	}
    };
    acTools.onMessage = function(device_id, data) {
    	if(data.listener){
    		acTools.listeners[data.listener](device_id, data);
    	}
    	for (var i = 0; i < acTools.uniListeners.length; i++) {
    		acTools.uniListeners[i](device_id, data);
    	}
    };
    
    var airconsole = new AirConsole({orientation: AirConsole.ORIENTATION_LANDSCAPE});
    
    
    function init() {
      
      airconsole.onMessage = acTools.onMessage;
      
      var acInterval = setInterval(function(){
        airconsole.message(AirConsole.SCREEN, {listener: 'ready'});
      }, 2000);
      
      acTools.addListener('ready', function(from, data){
        if(from == AirConsole.SCREEN){
          clearInterval(acInterval);
          airconsole.message(AirConsole.SCREEN, {
            listener: 'newPlayer',
            nick: nickname,
            controller: 'controller'
          });
        }
      });

      // debug info
      acTools.addListener(undefined, function(from, data){
	      console.log('on ctrl: ', from, data);
      });
      
      window.addEventListener("deviceorientation", function(e){
        console.log(e);
      })

      /*
       * Checks if this device is part of the active game.
       */
      airconsole.onActivePlayersChange = function(player) {
        var div = document.getElementById("player_id");
        // if (player !== undefined) {
        //   div.innerHTML =  (["Left Player", "Right Player"][player]);
        // } else {
        //   div.innerHTML = "It's a 2 player game!";
        // }
      };

      /*
       * Makes the device vibrate if the screen says so.
       */
      acTools.addListener('vibrator', function(from, data) {
        if (from == AirConsole.SCREEN && data.vibrate) {
          navigator.vibrate(data.vibrate);
          console.log("Vibrating: " + data.vibrate);
        }
      });
      
      document.addEventListener('click',function(e){
  	  	var clickedElement = e.target;
  	  	if (clickedElement.nodeName == 'IMG'){
  	  	  unselectAll(clickedElement);
  	  	  clickedElement.className += ' selected';
  	  	}
	    })
    }
    
    

  function getPlayerInfo(name, color){
    
    var color = getColor();
    nickname  = getName();
    
    console.log(color, nickname);
    
    if(color && nickname){
      
      document.getElementById("name-and-color-container").style.display = "none";
      document.getElementById("gamepad-container").style.display = "block";
      
      addPlayer(nickname, color);
      
    }
  }
  
  function addPlayer(name, color){
    acTools.addListener('ready', function(from, data){
      if(from == AirConsole.SCREEN){
       //clearInterval(acInterval);
       airconsole.message(AirConsole.SCREEN, {listener: 'newPlayer', nick: nickname, color:color, controller: true});
      }
    });
    airconsole.message(AirConsole.SCREEN, {listener: 'ready'});
  }
  
   function getColor(){
  	var el = document.getElementsByClassName('selected');
  	if (el[0]){
  	  var reg = /[a-z]+(?=.png)(?!_)/;
  	  var color = reg.exec(el[0].currentSrc);
  	}
  	
    return color[0];
  }
  
  function getName(){
    return document.getElementById('player_name').value;
  }
      
  function unselectAll(clickedElement){
    var allCharacters = document.getElementsByClassName(clickedElement.className);
    for(var i = 0; i < allCharacters.length; i++)
      allCharacters[i].classList.remove('selected');
  }

    /**
     * Tells the screen to move the paddle of this player.
     * @param amount
     */
    function move(amount) {
      airconsole.message(AirConsole.SCREEN, {listener: 'movePlayer', nick: nickname, x: amount.x, y: amount.y});
    }
    function bomb(setting) {
      airconsole.message(AirConsole.SCREEN, {listener: 'setBomb', nick: nickname, setting: setting});
    }
      
    new DPad("my-DPad", {
      // Set to true if you want to have a relative swipe dpad
      "relative": false,
      // Gets called when the dpad direction changes.
      // Key is one of: DPad.UP, DPad.DOWN, DPad.LEFT, DPad.RIGHT.
      // Pressed is a boolean, true if the direction is active.
      "directionchange": function(key, pressed) {
        switch(key) {
            case 'right':
                pressed ? move({x:1}) : move({x: 0});
                break;
            case 'left':
                pressed ? move({x:-1}) : move({x: 0});
                break;
            case 'up':
                pressed ? move({y:-1}) : move({y: 0});
                break;
            case 'down':
                pressed ? move({y:1}) : move({y: 0});
                break;
        }
      },

      // // Gets called when the DPad is touched.
      // "touchstart": function() {
      //   console.log('touch start');
      // },

      // // Gets called when the DPad is released.
      // // had_direction is a boolean that tells you if at lease one direction was active.
      // //               can be used to determine if it was just a "tap" on the DPad.
      // "touchend": function(had_direction) {
      //   console.log('touch end', had_direction);
      // },

      // (Optional) distance which the user needs to move before triggering a direction.
      "distance": {x: 10, y:10},

      // (Optional) diagonal: If true, diagonal movement are possible and it becomes a 8-way DPad:
      //                      For exmaple UP and RIGHT at the same time.
      "diagonal": true
    });
    
    new Button("button-bomb", {
        "down": function() {
          bomb('setting');
        },
        "up": function() {
          bomb(!'setting');
        }
      });
    
</script></body></html>